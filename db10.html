<h1>1.</h1>
엔티티: 사람, 장소, 사물, 사건 등과 같이 독립적으로 존재하면서 고유하게 식별이 가능한 실세계의 객체
엔티티 타입: 동일한 애트리뷰트들을 가진 엔티티들의 틀
단순 애트리뷰트: 더 이상 나눌 수 없는, 최소 단위의 애트티뷰트
복합 애트리뷰트: 둘 이상의 애트리뷰트로 이루어진 애트리뷰트. 연관되어 있는 애트리뷰트를 연결한 집합은 복합 애트리뷰트이다.
다치 애트리뷰트: 엔티티마다 여러 개의 값을 가지는 것이 가능한 애트리뷰트이다.
유도된 애트리뷰트: 다른 애트리뷰트의 값으로부터 얻어진 애트리뷰트
탐색 키: 순차 파일을 정렬하는 데 사용되는 필드
히프 화일: 순서가 없으며, 레코드들이 삽입된 순서대로 파일의 끝에 저장됨.
클러스터링 인덱스: 탐색 키 값에 따라 정렬된 데이터 파일에 대해 정의됨. 각 데이터 블록 대신에 각각의 상이한 키 값마다 하나의 인덱스 엔트리가 인덱스에 포함되어 탐색 키 값을 갖는 첫 번째 레코드의 주소를 가리킴
밀집 인덱스: 각 레코드의 키 값에 대해서 인덱스에 엔트리를 유지하는 인덱스
희소 인덱스: 일부 키 값에 대해서만 인덱스에 엔트리를 유지하는 인덱스
다단계 인덱스: 단일 단계 인덱스의 경우 인덱스 자체가 커지면 탐색하는 데 오래 걸리는 문제점이 있음. 이를 해결하기 위해 단일 단계 인덱스에 대해 다시 인덱스를 정의해 탐색 시간을 줄임. 이를 다단계 인덱스라 함.

<h1>2.</h1>
엔티티 타입은 동일한 애트리뷰트를 가지는 엔티티의 틀로써 엔티티들을 관리하기 쉽도록 역할과 속성에 따라 묶는 단위이기도 하다.
강한 엔티티 타입과 약한 엔티티 타입의 차이점은 자신의 타입 내에서 가진 애트리뷰트로 엔티티들을 고유하게 식별할 수 있는가이다. 강한 엔티티 타입은 고유하게 식별할 수 있으나 약한 엔티티 타입은 그렇기에 충분하지 못 한 애트리뷰트를 가지고 있기 때문에 소유 엔티티 타입으로부터 고유한 식별이 가능하도록 키를 제공받아야만 한다.

<h1>4.</h1>
자체적으로 가지고 있는 애트리뷰트의 값에서 고유하게 식별이 안 되는 상황에서 약한 엔티티에 키를 추가해 고유하게 식별할 수 있도록 만들 수 있다. 예를 들어, 학생의 이름의 경우 동명이인이 생길 수 있지만, 학번을 키로써 추가한다면 고유하게 식별할 수 있게 된다. 

<h1>5.</h1>
독립적으로 존재하면서 '고유하게 식별이 가능하면' 모두 엔티티이다. 따라서 커피, 의자는 엔티티이다. 중력의 경우 실체가 존재하지는 않으나, 고유하게 식별하는 것은 가능하므로 엔티티이다. 실체가 꼭 존재하지 않는 개념, 추상이더라도 엔티티일 수 있다.

<h1>6.</h1>
WORKS_FOR에 포함되어야 한다. PROGRAMMER 앤티티 타입과 PROJECT 타입을 이어주고 있기 때문이다.

<h1>8.</h1>
단순 애트리뷰트: firstname, lastname, studno, examscore, no. of students, COURSENO, equip, name
복합 애트리뷰트: name
다치 애트리뷰트: examscore
기본 키 애트리뷰트: studno, COURSENO
유도된 애트리뷰트: no. of students
관계 타입이 가진 애트리뷰트: examscore, no. of students

